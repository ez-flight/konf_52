import math


def compute_N_terms(Rs, Vs, R_s, V_s, We, ay, Lam, Fd, R_0, R_e):
    """
    Вычисление общих термов N1, N2, N0 для уравнений доплеровской частоты и угла.
    Оптимизация: централизация повторяющихся вычислений для устранения дублирования кода.
    
    Параметры:
    Rs (tuple): Координаты КА в геоцентрической системе (X, Y, Z) [км]
    Vs (tuple): Скорости КА в геоцентрической системе (Vx, Vy, Vz) [км/с]
    R_s (float): Модуль радиус-вектора КА [км]
    V_s (float): Модуль вектора скорости КА [км/с]
    We (float): Угловая скорость вращения Земли [рад/с]
    ay (float): Угол атаки [рад]
    Lam (float): Длина волны сигнала [км]
    Fd (float): Доплеровская частота [Гц]
    R_0 (float): Дистанция до цели [км]
    R_e (float): Экваториальный радиус Земли [км]

    Возвращает:
    tuple: Вычисленные значения (N1, N2, N0)
    """
    # Распаковка координат и скоростей
    X_s, Y_s, Z_s = Rs
    Vx_s, Vy_s, Vz_s = Vs

    # Скалярное произведение векторов положения и скорости
    dot_product = X_s * Vx_s + Y_s * Vy_s + Z_s * Vz_s
    
    # Вычисление угла между векторами положения и скорости
    denominator_acos = R_s * V_s
    if denominator_acos == 0:
        raise ValueError("R_s or V_s is zero, division by zero.")
    Q = math.acos(dot_product / denominator_acos)  # Угол Q в радианах
    sin_Q = math.sin(Q)
    C = R_s * V_s * sin_Q  # Модуль векторного произведения

    if C == 0:
        raise ValueError("C is zero, division by zero.")

    # Компоненты векторного произведения [Rs × Vs]
    C1 = Y_s * Vz_s - Z_s * Vy_s
    C2 = Z_s * Vx_s - X_s * Vz_s
    C3 = X_s * Vy_s - Y_s * Vx_s

    # Вычисление элементов матрицы преобразования
    inv_CRs = 1 / (C * R_s)  # Оптимизация: повторное использование вычислений
    nn11 = inv_CRs * (C2 * Z_s - C3 * Y_s)
    nn12 = C1 / C
    nn13 = X_s / R_s  # Направляющий косинус по X

    nn21 = inv_CRs * (C3 * X_s - C1 * Z_s)
    nn22 = C2 / C
    nn23 = Y_s / R_s  # Направляющий косинус по Y

    nn31 = inv_CRs * (C1 * Y_s - C2 * X_s)
    nn32 = C3 / C
    nn33 = Z_s / R_s  # Направляющий косинус по Z

    # Вычисление компонент скоростного вектора с учетом вращения Земли
    term_Vx = -Vx_s - We * Y_s  # Коррекция скорости по X
    term_Vy = -Vy_s - We * X_s  # Коррекция скорости по Y
    term_Vz = -Vz_s             # Скорость по Z

    # Вычисление составляющих для N-термов
    N1_part = term_Vx * nn11 + term_Vy * nn21 + term_Vz * nn31
    N2_part = term_Vx * nn12 + term_Vy * nn22 + term_Vz * nn32
    N0_part = term_Vx * nn13 + term_Vy * nn23 + term_Vz * nn33

    # Тригонометрические константы для оптимизации
    cos_ay = math.cos(ay)  # Косинус угла атаки
    sin_ay = math.sin(ay)  # Синус угла атаки

    # Финальные вычисления N-термов
    N1 = R_e * cos_ay * N1_part  # Составляющая N1
    N2 = R_e * cos_ay * N2_part  # Составляющая N2
    N0 = R_e * sin_ay * N0_part + Lam * Fd * R_0 / 2 + dot_product  # Свободный член N0

    return N1, N2, N0

def calc_lamda(Fd, Lam, ay, Rs, Vs, R_0, R_e, R_s, V_s):
    """
    Вычисление угла места (λ) в градусах.
    Оптимизация: использование math.atan2 вместо math.atan для корректного определения квадранта.
    
    Параметры:
    Fd (float): Доплеровская частота [Гц]
    Lam (float): Длина волны [км]
    ay (float): Угол атаки [рад]
    ... (остальные параметры аналогичны compute_N_terms)
    
    Возвращает:
    float: Угол места в градусах [0, 360)
    """
    We = 7.2292115E-5  # Угловая скорость Земли (постоянная)

    try:
        # Получение общих термов
        N1, N2, N0 = compute_N_terms(Rs, Vs, R_s, V_s, We, ay, Lam, Fd, R_0, R_e)
        
        denominator = math.sqrt(N1**2 + N2**2)
        if denominator == 0:
            raise ValueError("Denominator is zero.")
        
        # Вычисление аргумента для арксинуса с проверкой диапазона
        arg = -N0 / denominator
        if arg < -1 or arg > 1:
            # Обработка исключительных ситуаций (выход за пределы [-1, 1])
            Lam_f = math.pi / 2  # Значение по умолчанию 90°
        else:
            # Основная формула: λ = arcsin(-N0/|N|) - arctan(N1/N2)
            Lam_f = math.asin(arg) - math.atan2(N2, N1)  # math.atan2(y, x) дает корректный угол
        
    except ValueError as e:
        # Обработка ошибок вычислений
        Lam_f = math.pi / 2
        print(f"Ошибка вычисления: {e}")

    # Преобразование радиан в градусы
    Lam_f_deg = math.degrees(Lam_f)
    
    # Нормализация угла в диапазон [0, 360)
    if Lam_f_deg < 0:
        Lam_f_deg += 360  # Компенсация отрицательных значений
    
    return Lam_f_deg % 360  # Гарантированный результат в [0, 360)

def calc_f_doplera(a, Lam, ay, Rs, Vs, R_0, R_e, R_s, V_s):
    """
    Вычисление доплеровской частоты (Fd).
    Оптимизация: повторное использование compute_N_terms и предвычисление тригонометрических функций.
    
    Параметры:
    a (float): Угол между плоскостями [град]
    ... (остальные параметры аналогичны предыдущим функциям)
    
    Возвращает:
    float: Доплеровская частота [Гц]
    """
    We = 7.2292115E-5
    a_rad = math.radians(a)  # Преобразование угла в радианы
    Fd_initial = 0.0  # Начальное приближение для Fd
    
    try:
        # Получение общих термов (Fd=0 в первом приближении)
        N1, N2, N0 = compute_N_terms(Rs, Vs, R_s, V_s, We, ay, Lam, Fd_initial, R_0, R_e)
        
        # Основная формула доплеровской частоты
        Fd = (2.0 / (Lam * R_0)) * (math.cos(a_rad) * N1 + math.sin(a_rad) * N2 - N0)
    
    except ValueError as e:
        # Обработка ошибок при вычислении N-термов
        print(f"Ошибка вычисления Fd: {e}")
        Fd = 0.0
    
    return Fd

def _test():
    """
    Тестовый пример для проверки работы функций.
    Использует реалистичные параметры орбиты КА.
    """
    # Тестовые параметры
    Fd = 0.0       # Начальное значение доплеровской частоты
    Lam = 0.000096 # Длина волны L-диапазона (~3 ГГц)
    ay = 0.9425    # Угол атаки ~54 градуса (в радианах)
    Rs = (463.35, -1207.81, -6768.48)  # Положение в ECEF (пример)
    Vs = (-2.9576, -6.9186, 1.0337)    # Скорость в ECEF (пример)
    R_0 = 12616.94 # Дистанция до цели
    R_s = 6890.99  # Высота орбиты (примерно 500 км)
    R_e = 6374.15  # Экваториальный радиус Земли
    V_s = 7.5949   # Орбитальная скорость (~7.5 км/с)

    # Расчет доплеровской частоты для угла 90 градусов
    a = 90
    Fd = calc_f_doplera(a, Lam, ay, Rs, Vs, R_0, R_e, R_s, V_s)
    print(f"Рассчитанная доплеровская частота: {Fd:.4f} Гц")

    # Расчет угла места
    Lam_f = calc_lamda(Fd, Lam, ay, Rs, Vs, R_0, R_e, R_s, V_s)
    print(f"Рассчитанный угол места: {Lam_f:.2f}°")

if __name__ == "__main__":
    _test()